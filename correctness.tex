\section{Compiler Correctness} \sec{sec:correctness}

In this section we define a relation between the state of the small step
semantics and the state of the instruction machine semantics, and show that the
instruction machine implements the small step source semantics under that
relation. 

In general, we implement closures as instruction pointer, environment pointer
pairs. For the instruction pointers, we relate them to terms via the compile
function defined in Section~\ref{compiler}. Essentially, we require that the
instruction pointer point to a list of basic blocks that the related term
compiles to. For the current closure, we relate the instruction pointer in the
instruction machine to the current term in the small step source semantics. The
environment pointers of each machine are more similar. Given a relation between
the heaps of the two machines, we define the relation between two environment
pointers as existing in the relation of the heaps, or both being the null
pointers. While it should be possible to avoid this special case, during the
proof it became apparent that not having the special case made the proof
significantly harder. This forces us to add the constraint to all machines that
pointers are non-null, which for real hardware shouldn't be an issue.  

It's important to point out that we use null pointers in two crucial ways. One
is to explicitly define the root of the shared environment structure in both the
source semantics and the machine semantics. The next is for instruction
pointers. To differentiate between update markers and pointers to basic blocks,
we use a null pointer to refer to an update marker, and a non-null pointer as an
instruction pointer for an argument closure. Note that in fact, while the null
pointers in heaps required us to only allocate non-null fresh locations in the
heaps of our semantics, using null pointers to denote update markers requires no
change to our program generation, due to the fact that an argument term of an
application cannot occur at position 0 in the program.

The relation between the heaps of the small step source semantics and the
instruction machine is the trickiest part of the state relation. Note that for
each location in the source semantics heap, we have a cell with a closure and
environment continuation pointer. Naturally, the instruction machine represents
these as three pointers: two for the closure (the instruction pointer and
environment pointer) and one for the environment continuation. The easiest
approach turned out to use the structure of the heap constructs to define a
one-to-three mapping between this single cell and the three machine words. The
structure used for the each of the heaps is a list of pointer, value bindings.
We use the ordering of these bindings in the list to define a one binding to
three binding mapping between the source heap and the machine heap. We define an
analogue to the standard \texttt{In} list relation that defines when an element
is in a list for this heap relation, proceeding recursively on the inductive
relation structure. This allows us to define a notion of which pairs of each
type of closure are in the heap, along with their respective locations. Due to
the ordering that they are allocated in the heap during evaluation, each pair of
memory allocations corresponds to an equivalent closure. We use this property as
as a kind of heap equivalence property that is preserved through evaluation:
every binding pair in the heap relation property described above defines
equivalent closures and environment continuations. For the relation between our
stacks, we define a similar notion: we require that every update marker points
to related environments: they are two pointers that exist in the heap relation,
and that every closure is equivalent: the instruction pointer and environment
pointer are equivalent to their respective counterparts in the small step
semantics. 

In summary, we require that the current closure in the small step semantics is
equivalent to the closure represented by the instruction pointer, environment
pointer pair, and that the stacks and the heaps are equivalent.  

Now that we have our relation between heaps, we can state our primary lemma.
\begin{lemma}
Given that an instruction machine state $i$ is related to a small step
semantics state $s$, and that small step semantics state steps to a new state
$s'$, the instruction machine will step in zero or more steps to a related state
$i'$.
\end{lemma}
\begin{proofoutline}
Our proof proceeds by case analysis on the step rules for the small step
semantics. We'll focus on the second half of the proof, that $i'$ is related to
$s'$. The proofs that $i$ evaluates to $i'$ follow fairly directly from the
definition given in Section~\ref{compiler}. For the Var rule, because we need to
proceed by induction, we have to proceed by induction on a basicblock while
ignoring of the program, then use the resulting proof to show that evaluation of
a compiled variable implements the evaluation of the variable in the small step
semantics. In particular, we use the null environment as a base case for our
induction, as we know the only way lookup could fail is if both environnment
pointers are null, but that cannot be the case due to the fact that we know that
the small step semantics must have succesfully looked up its environment pointer
in the heap. Thefore the only option is for both environment pointers to exist
in the heap relation, which when combined with the heap equivalence relation in
the outer proof gives us the necessary property that the environment
continuations are equivalent. Finally, because the last locations reached must
have been in the heap relation, we know they are equivalent environment
pointers, and therefore the stack relation is preserved when we push the update
marker onto the heap. For the App rule, we use the definition of our compiler to
prove that the argument term and argument instruction pointer are equivalent and
that the left hand side term and instruction pointer are also equivalent. They
share an environment pointer which is equivalent by the fact that the
application closures are related. This proves that the stack relation is
preserved as well as the current closure, while the heap is unchanged. For the
Lam rule, we allocate a fresh variable and because of our stack relation we can
be sure that the closures that we allocate are equivalent, as well as the
environment continuations, as they are taken from the previous current
continuation. Because of how we define it, the new allocations are equivalent
under our heap relation, and preserve heap equivalence. Finally, the Upd rule
trivially preserves the stack and current closure relations, and for proving
that the relation is preserved for the heap, we proceed by induction on the heap
relation. In addition, we must prove a supporting lemma that all environment
relations are preserved by the update. 
\end{proofoutline}

To paraphrase Pascal: given more time, I would have written a shorter proof.

