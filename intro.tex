\section{Introduction}
Call-by-need semantics are heavily relied on in languages like Haskell to ensure
efficient execution of non-strict semantics. These semantics let programmers
focus more on the correctness and composability of their code, without worrying
so much about operational properties. 

Verified compilers provide powerful guarantees about the code they generate, and
its relation to the corresponding source code. In particular, for higher order
functional languages, they can often ensure that the non-trivial task of
compiling lambda calculus and its derivatives to machine code is implemented
correctly, preserving some source semantics. There is a sense in which the
amortized return on investment for verified compilers is high: any reasoning
about any program which is compiled with a verified compiler is provably
preserved. 

Existing verified compilers have all focused on call-by-value semantics. This
semantics has the property of being historically easier to implement than
call-by-need, and therefore likely easier to reason about formally. In this
paper, we build on recent work developing a simple method for implementing
call-by-need semantics, enabling us to implement, and reason formally about the
correctness of, call-by-need. We use the Coq proof assistant \cite{coq} to
implement and prove the correctness of our compiler. We start with a source
language of $\lambda$ calculus with deBruijn indices:
\begin{align*}
 t &::= t \; t \; | \; x \; | \;  \lambda \; t \\
 x &\in \mathbb{N}
\end{align*}
Our source semantics is the big-step operational semantics of a recently
developed $\mathcal{CE}$ machine, which uses shared environments to share
results between instances of a bound variable. To strengthen the result, we also
show that the $\mathcal{CE}$ machine implements Curien's call-by-name calculus
of closures. Combining these results shows that the compiler correctly
implements both call-by-name and call-by-need.

It may surprise the reader to see that we don't start with a well-known
call-by-need semantics; we address this concern in in Section~\ref{discussion}.
To convince ourselves and the reader that we are correctly implementing
call-by-need, we state and prove the crucial property of call-by-need explicitly
as a Lemma: any bound closure will be evaluated at most once. This, combined
with the proof that we implement Curien's call-by-name semantics should convince
any reader that we have indeed implemented a call-by-need semantics, despite not
using an well-known definition of call-by-need. 

Our compiler target is a simple assembly language and corresponding instruction
machine, similar to that used in \cite{chlipala_verified}. 
\begin{figure}
\begin{align*}
  \tag{Word}   n, p &\in \mathbb{N} \\
  \tag{Registers} r &::= ip \; | \; ep \; | \; r1 \; | \; r2  \\
  \tag{Write Operands}  wo &::= r \; | \; r\%n \\
  \tag{Read Operands}  ro &::= wo \; | \; n \\
  \tag{Basic Blocks} bb &::= i \; ; \; bb \; 
                       | \; \texttt{jmp} \; \{(ro, n)\} \; ro \;  \\
  \tag{Instructions} i &::= \texttt{mov} \; ro \; wo \; 
                       | \; \texttt{new} \; n \; wo \; \\
  \notag   & \quad \;  | \; \texttt{push} \; ro \; 
                       | \; \texttt{pop} \; wo 
\end{align*}
\label{fig:im_syntax}
\caption{Instruction Set Syntax}
\end{figure}
This simple target allows us to describe the compiler and proofs in a concise
way for the paper, while still allowing flexibility in eventually verifying a
compiler down to machine code for some real hardware, e.g. x64.

The paper is structured as follows. In Section~\ref{background} we give the
necessary background for the paper. In Section~\ref{cem_big} we describe the
source syntax and semantics (the big-step $\mathcal{CE}$ semantics) in detail.
In Section~\ref{cem_small} we describe the small step $\mathcal{CE}$ semantics
and their relation to the big-step semantics.  In Section~\ref{im} we describe
the instruction machine syntax and semantics. In Section~\ref{db_assembly} we
describe the compilation from machine terms to assembly language, i.e. the
compiler. In Section~\ref{im_semantics} we describe the instruction machine
semantics, and show how evaluation of compiled programs is related to the small
step $\mathcal{CE}$ semantics. the compilation of terms into assembly language,
and the instruction machine semantics. In Section~\ref{discussion} we discuss
threats to validity, future work, and related work. Finally, we conclude in
Section~\ref{conclusion}.


