\section{Introduction} \label{sec:introduction}
Call-by-need semantics are heavily relied on in languages like Haskell to ensure
efficient execution of non-strict semantics. These semantics let programmers
focus more on the correctness and composability of their code, without worrying
so much about operational properties. 

Verified compilers provide powerful guarantees about the code they generate, and
its relation to the corresponding source code. In particular, for higher order
functional languages, they can often ensure that the non-trivial task of
compiling lambda calculus and its derivatives to machine code is implemented
correctly, preserving some source semantics. There is a sense in which the
amortized return on investment for verified compilers is high: any reasoning
about any program which is compiled with a verified compiler is provably
preserved. 

Existing verified compilers have all focused on call-by-value semantics. This
semantics has the property of being historically easier to implement than
call-by-need, and therefore likely easier to reason about formally. In this
paper, we build on recent work developing a simple method for implementing
call-by-need semantics, enabling us to implement, and reason formally about the
correctness of, call-by-need. We use the Coq proof assistant \cite{coq} to
implement and prove the correctness of our compiler. We start with a source
language of $\lambda$ calculus with deBruijn indices:
\begin{align*}
 t &::= t \; t \; | \; x \; | \;  \lambda \; t \\
 x &\in \mathbb{N}
\end{align*}
Our source semantics is the big-step operational semantics of a recently
developed $\mathcal{CE}$ machine, which uses shared environments to share
results between instances of a bound variable. To strengthen the result, we also
show that the $\mathcal{CE}$ machine implements Curien's call-by-name calculus
of closures. Combining these results shows that the compiler correctly
implements both call-by-name and call-by-need.

It may surprise the reader to see that we don't start with a well-known
call-by-need semantics; we address this concern in in Section~\ref{sec:discussion}.
To convince ourselves and the reader that we are correctly implementing
call-by-need, we state and prove the crucial property of call-by-need explicitly
as a Lemma: any bound closure will be evaluated at most once. This, combined
with the proof that we our call-by-name version of the semantics implements
Curien's call-by-name semantics, should hopefully convince the reader that we
have indeed implemented a call-by-need semantics, despite not using an
well-known definition of call-by-need. 

This simple target allows us to describe the compiler and proofs in a concise
way for the paper, while still allowing flexibility in eventually verifying a
compiler down to machine code for some real hardware, e.g. x64.

The paper is structured as follows. In Section~\ref{sec:background} we give the
necessary background for the paper. In Section~\ref{sec:cem_big} we describe the
source syntax and semantics (the big-step $\mathcal{CE}$ semantics) in detail.
We also use this section to define a call-by-name version of the semantics, and
show that it implements Curien's calculus of closures \cite{curien}.  In
Section~\ref{sec:cem_small} we describe the small step $\mathcal{CE}$ semantics and
their relation to the big-step semantics. In
Section~\ref{sec:im_semantics} we describe the instruction machine syntax and
semantics. In Section~\ref{sec:compiler} we describe the compilation from
machine terms to assembly language. In Section~\ref{sec:correctness} we describe
how evaluation of compiled programs is related to the small step $\mathcal{CE}$
semantics. the compilation of terms into assembly language, and the instruction
machine semantics, and finally compose this proof with the proof that the
small step semantics implement the big step semantics to show that the
instruction machine implements the big step semantics. In
Section~\ref{sec:discussion} we discuss threats to validity, future work, and
related work. Finally, we conclude in Section~\ref{sec:conclusion}.

The Coq source code with all the definitions and proofs is available at
\url{https://github.com/stelleg/cem\_coq}. 
