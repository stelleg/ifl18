\section{$\mathcal{CE}$ Big-Step Semantics} \label{sec:cem_big}

In this section we define our big-step source semantics. Big-step semantics
has the advantage of powerful, easy-to-use induction properties. This eases
reasoning about many program properties. We shall also define a small-step
semantics and prove that it implements the big-step semantics, but by showing
that our implementation preserves the big-step semantics, we prove preservation
of any inductive reasoning on the structure of evaluation tree.  

As discussed in Section~\ref{sec:introduction}, our source syntax is lambda calculus with
de Bruijn indices. DeBruijn indices count the number of intermediate lambdas
between them and their binding lambda.  
\begin{align*}
 t &::= t \; t \; | \; x \; | \;  \lambda \; t \\
 x &\in \mathbb{N}
\end{align*}

Throughout the rest of this paper, we will use Coq code directly to formalize
some of the definition and theorems in the paper. This has the advantage of
avoiding ambiguities and correctness issues involved in translating to \LaTeX.
For example, the Coq code defining lambda calculus with de Bruijn indices is: 

\begin{lstlisting}
Inductive tm : Type := 
  | var : nat -> tm 
  | lam : tm -> tm
  | app : tm -> tm -> tm.
\end{lstlisting}

The essence of the $\mathcal{CE}$ semantics is that we implement a shared
environment, and use its structure to share results of computations. This allows
for a simple abstract machine which can operate on lambda calculus directly,
which is uncommon among call-by-need abstract machines
\cite{jonesstg,launchburynatural,TIM,johnsson1984efficient}. This simplifies
formalization, as we do not need to prove that these transformations are
semantics-preserving. Another advantage to the $\mathcal{CE}$ machine is that it
has constant sized closures, obviating the need to reason about re-allocating
the results of computation and adding indirections due to closure size changes
from thunk to value \cite{jonesstg}. We operate on closures, which combine terms with
pointers into the shared environment, which is implemented as a heap. Every heap
location points to a cell, which contains a closure and a pointer to the next
environment location if necessary, which we will refer to as the environment
continuation. Variable dereferences index into this shared environment
structure, and if/when a dereferenced location evaluates to a value, the
original closure (potentially a thunk or closure not evaluated to WHNF) will be
replaced with said value. The binding of a new variable extends the shared
environment structure with a new cell. This is done by application, which
evaluates the left hand side to an
abstraction, then extend the environment with the argument term closed under the
environment pointer at the environment of the application. The application rule
enforces the fact that two variables bound to the same argument closure will
point to the same location in the shared environment. Because they point to the
same location by construction of the shared environment, we can update that
location with the value computed at the first variable dereference, and then
each subsequent dereference will point to this value. The variable rule applies
the update by indexing into the shared environment structure and replacing the
closure at that location with the resulting value. The big-step semantics is
described in the standard way by logical relation in Figure~\ref{fig:bigstep}. A
few notes about definitions used in the semantics: the \texttt{update $\Psi$ x
v} function replaces the closure at location \texttt{x} in heap $\Psi$ with
value \texttt{v}. The curly brackets (or the \texttt{cl} constructor,
depending on context) construct a heap cell containing a closure and a
environment continuation. The \texttt{app} constructor represents an
application, while the \texttt{var} constructor is a variable constructor and
$\lambda$ is the constructor for an abstraction. The \texttt{clu} function looks
up a variable index in the shared environment structure by following environment
continuation pointers. The $\langle \Phi \rangle \texttt{c}$ notation constructs
a configuration from a heap $\Phi$ and a closure \texttt{c}. Note that we
require that fresh heap locations are greater than zero. This is required for
reasoning about compilation to the instruction machine, which we will return to
in Section~\ref{sec:im_semantics}. The \texttt{isfresh} relation is defined as
$f \notin dom \big( \Psi \big)$. Of course, for a real implementation, this is
far too strong a constraint, as it doesn't allow any sort of heap re-use. We
return to this issue in Section~\ref{sec:discussion}, and discuss how this could
be relaxed to either allow reasoning about garbage collection or direct
heap-reuse.

\begin{figure}
\begin{lstlisting}
Fixpoint clu (v env:nat) (h:heap) : option (nat * cell) := 
  match lookup env h with
  | None => None
  | Some (cl c a) => match v with
    | S n => clu n a h
    | 0 => Some (env, cl c a)
    end
  end.

Inductive step : conf -> conf -> Type :=
  | Id : $\forall$ M x y z $\Phi$ $\Psi$ v e, 
              clu y e $\Phi$ = Some (x, {M, z}) -> 
                    $\langle$$\Phi$$\rangle$M $\Downarrow$ $\langle$$\Psi$$\rangle$v ->
      $\langle$$\Phi$$\rangle$close (var y) e $\Downarrow$ $\langle$update $\Psi$ x v$\rangle$v
  | Abs : $\forall$ N $\Phi$ e, 
          $\langle$$\Phi$$\rangle$close ($\lambda$N) e $\Downarrow$ $\langle$$\Phi$$\rangle$close ($\lambda$N) e
  | App : $\forall$ N M B B' $\Phi$ $\Psi$ $\Upsilon$ f e ne ae, 
                      isfresh (domain $\Psi$) f -> 
                            f > 0 ->
          $\langle$$\Phi$$\rangle$close M e $\Downarrow$ $\langle$$\Psi$$\rangle$close ($\lambda$B) ne -> 
      $\langle$$\Psi$, f â†¦ {close N e, ne}$\rangle$close B f $\Downarrow$ $\langle$$\Upsilon$$\rangle$close ($\lambda$B') ae   ->
              $\langle$$\Phi$$\rangle$close (app M N) e $\Downarrow$ $\langle$$\Upsilon$$\rangle$close ($\lambda$B') ae
where " c1 '$\Downarrow$' c2 " := (step c1 c2).
\end{lstlisting}
\caption{Big Step $\mathcal{CE}$ Semantics}
\label{fig:bigstep}
\end{figure}

In addition to the above description there are some important properties to
notice for the purpose of verification. One is that we specify that in addition
to requiring that a heap location for a new bound closure is fresh, we require
that it is positive. While not necessary for the correctness of the
semantics, this will be useful later when defining a relation between the heap
described here and the machine code heap, ensuring that we do not artificially
extend the empty environment. It is also worth noting that while the closures in
the heap cells are mutable, the shared environment structure is never mutated.
This property is crucial when reasoning about variable dereferences. 

The fact that our natural semantics is defined on lambda calculus with de Bruijn
tindices differs from most existing definitions of call-by-need, such as
Ariola's call-by-need \cite{ariola1995call} or Launchbury's lazy semantics
\cite{launchburynatural}. These semantics are defined on lambda calculus with named
variables. While it should be possible to relate our semantics to these
\footnote{Both of these well known existing semantics have known problems, as
discussed in Section~\ref{sec:discussion}}, the comparison is certainly made
more difficult by this disparity. A more fruitful relation to semantics
operating on lambda calculus with named variables would likely be relating
Curien's calculus of closures to call-by-name semantics implemented with
substitution. We return to this discussion in Section~\ref{sec:discussion}.

As mentioned in Section~\ref{sec:introduction}, these big-step semantics do not
explicitly include a notion of nontermination. Instead, nontermination would be
implied by the negation of the existence of an evaluation relation. This
prevents reasoning directly about nontermination in an inductive way, but for
the purpose of our primary theorem this is fine. 

One interesting property of defining an inductive evaluation relation in a
language such as Coq is that we can do computation on the evaluation tree. In other
words, the evaluation relation given above defines a data type, one that we can
do computation on in standard ways. For example, we could potentially compute
properties such as size and depth, which would be related to operational properties
of compiled code. We hope in future work to explore this approach further.

Finally, given a term $t$, we define the initial configuration as $\langle [] \rangle
\texttt{close t 0}$. As discussed, the choice of the null pointer for the environment
pointer is not arbitrary, but chosen across our semantics uniformly to represent
failed environment lookup. 

\subsection{Call-By-Name}

In this section we define a call-by-name variant of our big-step semantics and
prove that it is an implementation of Curien's call-by-name calculus of
closures \cite{curien1991abstract}. 

See Figure~\ref{fig:bigstepname} for the definition of our call-by-name
semantics. Note that the only change from our call-by-need semantics is that we
do not update the heap location with the result of the dereferenced computation.
This is the essence of the difference between call-by-name and call-by-need.

A well known existing call-by-name semantics is Curien's calculus of closures
\cite{curien1991abstract}. Refer to Figure~\ref{fig:curien} for a formalization of this
semantics. This semantics defines closures as a term, environment pair, where an
environment is a list of closures. Abstractions are in weak head normal form,
variables index into the environment using the \texttt{nth\_error} standard
library function, and applications evaluate the left hand side to a value, then
extend the environment of the value with the closure of the argument. 

We define a heterogeneous equivalence relation between our shared environment
structure and Curien's structure. Effectively, this relation is the claim that
the shared environment structure is a linked list implementation of the
environment list in Curien's semantics. This is defined inductively, and we
require that every closure reachable in the environment is also equivalent.  We
say two closures are equivalent if their terms are identical and their
environments are equivalent. 

Given these definitions, we can prove that our call-by-name semantics implement
Curien's call by name semantics: 

\begin{theorem}
If a closure $c$ in Curien's call-by-name semantics is equivalent to a
configuration $c'$, and $c$ steps to $v$, then there exists a $v'$ that our
call-by-name semantics steps to from $c'$ that is equivalent to $v$.
\end{theorem}
\begin{proofoutline}
The proof proceeds by induction on Curien's step relation. The abstraction rule
is a trivial base case. The variable lookup rule uses a helper lemma that proves
by induction on the variable that if the two environments are equivalent and the
\texttt{nth\_error} function looks up a closure, then the \texttt{clu} function
will look up an equivalent closure. The application rule uses a helper lemma
proves that a fresh allocation will keep any equivalent environments equivalent,
and that the new environment defined by the fresh allocation will be equivalent
to the extended environment of Curien's semantics.
\end{proofoutline}

\begin{figure}
\begin{lstlisting}
Inductive closure := | close : tm -> list closure -> closure. 
Definition env := list closure.

Inductive step : closure -> closure -> Type := 
  | Abs : $\forall$ b e, 
      step (close ($\lambda$b) e) (close ($\lambda$b) e)
  | Var : $\forall$ x e v c, 
      nth_error e x = Some c -> 
      step c v -> 
      step (close (var x) e) v
  | App : $\forall$ m n b e v mve,
      step (close m e) (close ($\lambda$b) mve) ->
      step (close b (close n e::mve)) v ->
      step (close (app m n) e) v.
\end{lstlisting}
\caption{Curien's Calculus of Closures}
\label{fig:curien}
\end{figure}


\begin{figure}
\begin{lstlisting}
Inductive step : conf -> conf -> Type :=
  | Id : $\forall$ M x y z $\Phi$ $\Psi$ v e, 
          clu y e $\Phi$ = Some (x, {M, z}) -> 
                    $\langle$$\Phi$$\rangle$M $\Downarrow$ $\langle$$\Psi$$\rangle$v ->
            $\langle$$\Phi$$\rangle$close (var y) e $\Downarrow$ $\langle$$\Psi$$\rangle$v
  | Abs : $\forall$ N $\Phi$ e, 
        $\langle$$\Phi$$\rangle$close ($\lambda$N) e $\Downarrow$ $\langle$$\Phi$$\rangle$close ($\lambda$N) e
  | App : $\forall$ N M B B' $\Phi$ $\Psi$ $\Upsilon$ f e ne ae, 
              isfresh (domain $\Psi$) f -> 
                            f > 0 ->
          $\langle$$\Phi$$\rangle$close M e $\Downarrow$ $\langle$$\Psi$$\rangle$close ($\lambda$B) ne -> 
      $\langle$$\Psi$, f â†¦ {close N e, ne}$\rangle$close B f $\Downarrow$ $\langle$$\Upsilon$$\rangle$close ($\lambda$B') ae   ->
              $\langle$$\Phi$$\rangle$close (app M N) e $\Downarrow$ $\langle$$\Upsilon$$\rangle$close ($\lambda$B') ae
where " c1 '$\Downarrow$' c2 " := (step c1 c2).
\end{lstlisting}
\caption{Call-by-Name $\mathcal{CE}$ Semantics}
\label{fig:bigstepname}
\end{figure}

By proving that Curien's semantics is implemented by the call-by-name variant of
our semantics, we provide further evidence that our call-by-need is a
meaningful semantics. While eventually we would like to prove that the
call-by-need semantics implements an optimization of the call-by-name, we leave
that for future work.

One imporant note is that nowhere do we require that a term being evaluated is
closed by its environment. Indeed, it's possible that a term with free variables
can be evaluated by both semantics to a value as long as the free variable is
never dereferenced. This theme will recur through the rest of the paper, so it
is worth keeping in mind.  
